--- i2c-aspeed.c.orig	2016-07-25 09:23:29.630131361 +0300
+++ i2c-aspeed.c	2016-07-14 14:33:55.000000000 +0300
@@ -26,6 +26,7 @@
 #include <linux/slab.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
+#include <linux/pm_runtime.h>
 
 #include <linux/platform_device.h>
 #include <linux/err.h>
@@ -220,6 +221,7 @@
 #define AST_I2CD_CMDS	(AST_I2CD_BUS_RECOVER_CMD_EN | \
 			 AST_I2CD_M_STOP_CMD | \
 			 AST_I2CD_M_RX_CMD | \
+			 AST_I2CD_S_TX_CMD | \
 			 AST_I2CD_M_TX_CMD)
 
 static const int ast_i2c_n_busses = 14;
@@ -232,6 +234,7 @@ struct ast_i2c_bus {
 	void __iomem	*base;			/* virtual */	
 	u32 state;				//I2C xfer mode state matchine 
 	struct i2c_adapter adap;
+	struct i2c_client *slave;
 	u32		bus_clk;
 	struct clk	*pclk;
 	int		irq;
@@ -249,6 +252,10 @@ struct ast_i2c_bus {
 	u32		cmd_sent;
 	u32		cmd_pending;
 	u32		cmd_err;
+
+	/* Slave mode stuff */
+	bool		slave_op;	/* running slave operations */
+	u32		slave_req;	/* request type to slave */
 };
 
 struct ast_i2c_controller {
@@ -317,7 +324,6 @@ static void ast_i2c_dev_init(struct ast_
 	ast_i2c_write(bus, ast_i2c_read(bus, I2C_FUN_CTRL_REG)
 			| AST_I2CD_MASTER_EN, I2C_FUN_CTRL_REG);
 
-
 	/* Set interrupt generation of I2C controller */
 	ast_i2c_write(bus, AST_I2CD_INTR_SDA_DL_TIMEOUT |
 			AST_I2CD_INTR_BUS_RECOVER_DONE |
@@ -326,11 +332,11 @@ static void ast_i2c_dev_init(struct ast_
 			AST_I2CD_INTR_ABNORMAL |
 			AST_I2CD_INTR_NORMAL_STOP |
 			AST_I2CD_INTR_ARBIT_LOSS |
+			AST_I2CD_INTR_SLAVE_MATCH |
 			AST_I2CD_INTR_RX_DONE |
 			AST_I2CD_INTR_TX_NAK |
 			AST_I2CD_INTR_TX_ACK,
 			I2C_INTR_CTRL_REG);
-
 }
 
 static void ast_i2c_issue_cmd(struct ast_i2c_bus *bus, u32 cmd)
@@ -477,6 +483,7 @@ static bool ast_i2c_do_byte_xfer(struct
 
 		} else {
 			cmd = AST_I2CD_M_TX_CMD;
+			dev_dbg(bus->dev, "++ write [%02x]\n", bus->msg->buf[bus->msg_pos]);
 			ast_i2c_write(bus, bus->msg->buf[bus->msg_pos],
 					I2C_BYTE_BUF_REG);
 
@@ -518,6 +525,7 @@ static void ast_i2c_master_xfer_done(str
 						bus->msg->len -1);
 			}
 			bus->msg->buf[bus->msg_pos] = data;
+			dev_dbg(bus->dev, "++ read [%02x]\n", data);
 		}
 		bus->msg_pos++;
 	}
@@ -529,6 +537,73 @@ static void ast_i2c_master_xfer_done(str
 		complete(&bus->cmd_complete);
 }
 
+static void ast_i2c_bus_slave_irq(struct ast_i2c_bus *bus, u32 sts)
+{
+	u8 match;
+	u8 value;
+
+	dev_dbg(bus->dev, "slave irq: %08x  state %04x op: %d req: %d  slave: %p\n", sts, bus->state, bus->slave_op, bus->slave_req, bus->slave);
+
+//	if (!bus->slave)
+//		return;
+
+	if (sts & AST_I2CD_INTR_TX_NAK) {
+		/* Transmit done */
+		dev_dbg(bus->dev, "---GOT NAK---\n");
+		bus->slave_op = 0;
+		bus->slave_req = 0;
+		bus->cmd_err &= ~AST_I2CD_INTR_TX_NAK;
+		bus->cmd_pending &= ~AST_I2CD_S_TX_CMD;
+	} else if ((sts & AST_I2CD_INTR_SLAVE_MATCH) || bus->slave_op == 0) {
+		match = (ast_i2c_read(bus, I2C_BYTE_BUF_REG) >> 8) & 0xff;
+		dev_dbg(bus->dev, "S Start Addr match [%02x] ", match >> 1);
+		if (match & 1) {
+			bus->slave_req = I2C_SLAVE_READ_REQUESTED;
+			dev_dbg(bus->dev, "-- RD\n");
+		} else {
+			bus->slave_req = I2C_SLAVE_WRITE_REQUESTED;
+			dev_dbg(bus->dev, "-- WR\n");
+		}
+		bus->slave_op = 1;
+		if (bus->slave)
+		i2c_slave_event(bus->slave, bus->slave_req, &value);
+	} else if (sts & AST_I2CD_INTR_NORMAL_STOP || sts & AST_I2CD_INTR_ABNORMAL) {
+		bus->slave_op = 0;
+		if (bus->slave)
+		bus->cmd_pending &= ~AST_I2CD_S_TX_CMD;
+		i2c_slave_event(bus->slave, I2C_SLAVE_STOP, &value);
+		dev_dbg(bus->dev, "-- STOP\n");
+	} else if (bus->slave_req == I2C_SLAVE_READ_REQUESTED) {
+		if (bus->slave)
+		i2c_slave_event(bus->slave, I2C_SLAVE_READ_REQUESTED, &value);
+
+		ast_i2c_write(bus, value, I2C_BYTE_BUF_REG);
+		dev_dbg(bus->dev, "-- read [%02x]\n", value);
+		ast_i2c_issue_cmd(bus, AST_I2CD_S_TX_CMD);
+		// WRND: temporary unset var
+		bus->cmd_sent = 0;
+		// WRND
+		bus->slave_req = I2C_SLAVE_READ_PROCESSED;
+	} else if (bus->slave_req == I2C_SLAVE_READ_PROCESSED) {
+		value = (ast_i2c_read(bus, I2C_BYTE_BUF_REG) >> 8) & 0xff;
+		if (bus->slave)
+		i2c_slave_event(bus->slave, I2C_SLAVE_READ_PROCESSED, &value);
+		ast_i2c_write(bus, value, I2C_BYTE_BUF_REG);
+		dev_dbg(bus->dev, "-- read [%02x]\n", value);
+		ast_i2c_issue_cmd(bus, AST_I2CD_S_TX_CMD);
+		// WRND: temporary unset var
+		bus->cmd_sent = 0;
+		// WRND
+	} else if (bus->slave_req == I2C_SLAVE_WRITE_REQUESTED) {
+		value = (ast_i2c_read(bus, I2C_BYTE_BUF_REG) >> 8) & 0xff;
+		if (bus->slave)
+		i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_RECEIVED, &value);
+		dev_dbg(bus->dev, "-- write [%02x]\n", value);
+	}
+
+	ast_i2c_write(bus, sts, I2C_INTR_STS_REG);
+}
+
 static irqreturn_t ast_i2c_bus_irq(int irq, void *dev_id)
 {
 	struct ast_i2c_bus *bus = dev_id;
@@ -538,23 +613,32 @@ static irqreturn_t ast_i2c_bus_irq(int i
 		AST_I2CD_INTR_SCL_TIMEOUT |
 		AST_I2CD_INTR_SDA_DL_TIMEOUT |
 		AST_I2CD_INTR_TX_NAK;
-	u32 sts, cmd;
+	u32 sts, cmd, ctrl;
 
 	spin_lock(&bus->cmd_lock);
 
 	cmd = ast_i2c_read(bus, I2C_CMD_REG);
 	sts = ast_i2c_read(bus, I2C_INTR_STS_REG);
+	ctrl = ast_i2c_read(bus, I2C_INTR_CTRL_REG);
 
-	dev_dbg(bus->dev, "irq! status 0x%08x, cmd 0x%08x\n", sts, cmd);
+	dev_dbg(bus->dev, "irq! status 0x%08x, cmd 0x%08x, ctrl 0x%08x, int 0x%08x\n", sts, cmd, ctrl, sts & ctrl);
 
 	sts &= 0x7fff;
 	bus->state = cmd >> 19 & 0xf;
 
-	/* ack everything */
-	ast_i2c_write(bus, sts, I2C_INTR_STS_REG);
-
 	bus->cmd_err |= sts & errs;
 
+	if ((sts & AST_I2CD_INTR_SLAVE_MATCH) || bus->slave_op) {
+		ast_i2c_bus_slave_irq(bus, sts);
+		goto out;
+	}
+
+#if 0
+	if (sts & AST_I2CD_INTR_TX_NAK) {
+		dev_dbg(bus->dev, "--- NAK ---\n");
+		bus->cmd_err &= ~AST_I2CD_INTR_TX_NAK;
+	}
+#endif
 	/**
 	 * Mask-out pending commands that this interrupt has indicated are
 	 * complete. These checks need to cover all of the possible bits set
@@ -589,12 +673,14 @@ static irqreturn_t ast_i2c_bus_irq(int i
 	 * waiters. */
 	} else if (bus->cmd_sent) {
 		complete(&bus->cmd_complete);
-
 	} else {
 		dev_err(bus->dev, "Invalid state (msg %p, pending %x)?",
 				bus->msg, bus->cmd_pending);
 	}
 
+	/* ack everything */
+	ast_i2c_write(bus, sts, I2C_INTR_STS_REG);
+out:
 	spin_unlock(&bus->cmd_lock);
 
 	return IRQ_HANDLED;
@@ -691,14 +777,59 @@ out:
 	return ret;
 }
 
+#ifdef CONFIG_I2C_SLAVE
+static int ast_i2c_reg_slave(struct i2c_client *slave)
+{
+	struct ast_i2c_bus *bus = i2c_get_adapdata(slave->adapter);
+
+	if (bus->slave)
+		return -EBUSY;
+
+	if (slave->flags & I2C_CLIENT_TEN)
+		return -EAFNOSUPPORT;
+
+	pm_runtime_get_sync(bus->dev);
+
+	bus->slave = slave;
+	ast_i2c_write(bus, slave->addr, I2C_DEV_ADDR_REG);
+
+	ast_i2c_write(bus, ast_i2c_read(bus, I2C_FUN_CTRL_REG)
+			| AST_I2CD_SLAVE_EN, I2C_FUN_CTRL_REG);
+
+	return 0;
+}
+
+static int ast_i2c_unreg_slave(struct i2c_client *slave)
+{
+	struct ast_i2c_bus *bus = i2c_get_adapdata(slave->adapter);
+
+	WARN_ON(!bus->slave);
+
+	/* Disable Slave Mode */
+	ast_i2c_write(bus, ast_i2c_read(bus, I2C_FUN_CTRL_REG)
+			& ~(AST_I2CD_SLAVE_EN), I2C_FUN_CTRL_REG);
+
+	bus->slave = NULL;
+
+	pm_runtime_put(bus->dev);
+
+	return 0;
+}
+#endif
+
 static u32 ast_i2c_functionality(struct i2c_adapter *adap)
 {
-	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA;
+	return I2C_FUNC_I2C | I2C_FUNC_SLAVE |
+		I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA;
 }
 
 static const struct i2c_algorithm i2c_ast_algorithm = {
 	.master_xfer	= ast_i2c_xfer,
 	.functionality	= ast_i2c_functionality,
+#ifdef CONFIG_I2C_SLAVE
+	.reg_slave	= ast_i2c_reg_slave,
+	.unreg_slave	= ast_i2c_unreg_slave,
+#endif /* CONFIG_I2C_SLAVE */
 };
 
 static int ast_i2c_probe_bus(struct platform_device *pdev)
@@ -749,6 +880,7 @@ static int ast_i2c_probe_bus(struct plat
 	bus->adap.algo_data = bus;
 	bus->adap.dev.parent = &pdev->dev;
 	bus->adap.dev.of_node = pdev->dev.of_node;
+	i2c_set_adapdata(&bus->adap, bus);
 	snprintf(bus->adap.name, sizeof(bus->adap.name), "Aspeed i2c-%d",
 			bus_num);
 
@@ -863,7 +995,7 @@ static int ast_i2c_probe_controller(stru
 			continue;
 
 		of_platform_device_create(np, bus_id, &pdev->dev);
-		of_node_put(np);
+		//of_node_put(np);
 	}
 
 	return 0;
